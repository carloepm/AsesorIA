FECHA = 23/2/24
crear el campo clave correspondiente en chac_c de sql, luego, crear un l√±ogin en streamlit donde yo pueda registrar a un usuario y que me apareza un chat vacio, con la opcion de ponerle un nnombre al costado, TODO ESO SE GUARDA EN SQL, luego al empezar a hablar, los mensajes se guardan en cassandra, por ende, el mismo nombre de session de chat_c es el mismo nombre de session que el de message_store

FECHA = 26/2/24
Crear login,CREAR ASESOR (ANTES DEL CHAT) y registro de nueva conversacion, (parte del registro va para sql y el partition_id se registra solo en cassandra).
Hacer pruebas..

FECHA = 1/03/24
VER HERRAMIENTA NUEVA DE BUSQUEDA EN INTERNET y luego seguir hasta poder conseguir una lista de asesores para poder activar a cada objeto segun cada necesidad

1) organizar los campos de sql y crear el login para solo hacer el registro de usuario y nombre de chat.
2) que cpoincida el nombre del chac_c con el partition id de cassandra
3) usuario y chat_c en sql, conversacion en cassandra
4) hacer una consulta en visual studio code, para traer el chat de el usuario 1 y el usuario 2


avatar
T√∫

hola chat, estoy trabajando en un sistema con streamnlit, mi idea es hacer un menu lateral, donde pudiera tener un formulario apra crear a mi agente a la izquuerda , y en el lado derecho el chat, el tema es asi, una vez que yo creo el agente, se crea el chat tambien, pero no puedo poner el formulario en la izquierda, quizas deberia hacer un menu, que me deje entrar a ese menu una vez que me logeo en la web, yo lo que tengo es que cuando acceso a la web, tengo el login y el singup, el menu no lo puedo ver y eso esta bien, pero me gustaria que una vez que ingreso a la web, y hago mi login, despues no pueda acceder al menu del login, salvo que me deslogee que eso depsues lo vemos, te paso mi codigo, import streamlit as st from clase_sql_nosql import SQLServerUsuarios,SQLServerAsesorC ,AsesorManager,conexion_sql_server

conexion = conexion_sql_server() clase_usuarios = SQLServerUsuarios(conexion) clase_asesores = AsesorManager(conexion) clase_sql_asesores = SQLServerAsesorC(conexion)

st.set_page_config(page_title='Streamlit', page_icon='üêç', initial_sidebar_state='collapsed')

Session State login
if 'logged_in' not in st.session_state: st.session_state['logged_in'] = False if 'user_email' not in st.session_state: st.session_state['user_email'] = None

st.title("Bienvenido a :blue[ASESOR AI]") st.markdown("""Unite a la mejor asesor√≠a con IA Generativa.
Por qu√©? Estudios m√°s recientes muestran un 37% de eficiencia en las actividades laborales y cotidianas!""")

with st.form(key='login', clear_on_submit=False): st.subheader(':green[Login]') CorreoUsuario = st.text_input(':blue[Correo]', placeholder='Correo') if CorreoUsuario: CorreoUsuario_login = CorreoUsuario if clase_usuarios._verificar_correo(CorreoUsuario): st.success(':green[Correo v√°lido.]') else: st.error(':red[Correo err√≥neo o no esta registrado.]')

Contrase√±a = st.text_input(':blue[Contrase√±a]', placeholder='Contrase√±a', type= 'password')
if Contrase√±a:
    Contrase√±a_login = Contrase√±a
    if clase_usuarios.validar_login(CorreoUsuario, Contrase√±a):
        st.success(':green[Ingreso exitoso, bienvenido..]')
        st.session_state['logged_in'] = True
        st.session_state['user_email'] = CorreoUsuario

        ID_Usuario = clase_sql_asesores.obtener_id_usuario(CorreoUsuario)
        asesor_exists = clase_asesores.obtener_asesor_personal(ID_Usuario)
        if asesor_exists is not None:
            st.switch_page('C:/Dropbox/AsesorsIA/App-Asesoria/pages/page_asesor.py')
    #CONDICIONAL SI TIENE ASESORES CREADOS PARA DERIVAR A CHAT DONDE TENDRA MENU PARA CREAR ASESOR O SELECCIONAR EXISTENTE
        else:
            st.switch_page('C:/Dropbox/AsesorsIA/App-Asesoria/pages/page_asesor.py')
    else:
        st.error(':red[Contrase√±a err√≥nea.]')

login_button = st.form_submit_button('Ingresar')
signup = False

Inicializar Session State
if 'NombrePlan' not in st.session_state: st.session_state['NombrePlan'] = 'value'

Botones de planes
def handle_plan_free(): st.session_state["NombrePlan"] = "Plan Free"

def handle_plan_premium(): st.session_state["NombrePlan"] = "Plan Premium"

def handle_plan_pro(): st.session_state["NombrePlan"] = "Plan Pro"

st.header('Que esper√°s para unirte a nosotros? Crea una cuenta personal para la mejor asesor√≠a.') st.subheader("""Contamos el plan gratuito m√°s completo del mercado, lo demas es INCREIBLE""")

Crear los botones con la opci√≥n on_click
col1, col2, col3 = st.columns(3) if col1.button(":blue[Plan Free]", key='plan_free'): handle_plan_free() if col2.button(":green[Plan Premium]", key='plan_premium'): handle_plan_premium() if col3.button(":orange[Plan Pro]", key='plan_pro'): handle_plan_pro()

Mostrar el valor de la variable
NombrePlan = st.session_state.get("NombrePlan", None)

Formulario
with st.form(key='signup', clear_on_submit=False): st.subheader(':green[Sign Up]') NombreUsuario = st.text_input(':blue[Nombre]', placeholder='Nombre') if NombreUsuario: NombreUsuario_value = NombreUsuario if clase_usuarios._verificar_nombre(NombreUsuario): st.error(":red[Ingrese un nombre de usuario diferente.]") else: st.success(":green[Usuario valido]") st.info("Nuevo usuario: " + NombreUsuario)

CorreoUsuario = st.text_input(':blue[Correo]', placeholder='Correo')
if CorreoUsuario:
    CorreoUsuario_value = CorreoUsuario
    if clase_usuarios._verificar_correo(CorreoUsuario):
        st.error(":red[Correo electr√≥nico existente.]")
    else:
        st.success(":green[Correo valido.]")
        st.info("Correo registrado: " + CorreoUsuario)

Contrase√±a = st.text_input(':blue[Contrase√±a]', placeholder='Contrase√±a', type='password')
if Contrase√±a:
    Contrase√±a_value = Contrase√±a
    valid, error_msg = clase_usuarios._verificar_contrase√±a(Contrase√±a)
    if not valid:
        st.error(error_msg)
    else:
        st.success(":green[Contrase√±a correcta.]")

valid_user = clase_usuarios._verificar_nombre(NombreUsuario)
valid_correo = clase_usuarios._verificar_correo(CorreoUsuario)
valid, error_msg = clase_usuarios._verificar_contrase√±a(Contrase√±a)

# Verificar si todos los campos est√°n completos y si son validos
if NombreUsuario and CorreoUsuario and Contrase√±a and NombrePlan and valid_user == False and valid_correo == False and valid:
    signup = True
else:
    signup = False

# Agregar un bot√≥n de env√≠o al final del formulario
submit_button = st.form_submit_button("Registrar")
if submit_button and signup:
        autenticacion = clase_usuarios.add_usuario(NombreUsuario, CorreoUsuario, NombrePlan, Contrase√±a)
        st.success(":green[Registro exitoso.]")
        st.session_state['logged_in'] = True
        st.session_state['user_email'] = CorreoUsuario
        st.switch_page('C:/Dropbox/AsesorsIA/App-Asesoria/pages/page_asesor.py')
            
else:
    st.error(":red[Revisar registro: Datos faltantes o erroneos.]"). ESTO ES SOLO DEL LOGIN Y SNGUP, esto funciona bien, pero me gustaria, que cuando me voy a la otra paguina, ya que sea la paguina con el menu, me gustaria solo dos, el menu con el formulairo apra crear el agente y nombre de chat, y a la derecha cuando elijo alguno de los agentes creados, que se abra esa ventana de chat, solo quiero que me ayudes en la estructura para hacer un menu, despues yo ya tengo lo formularios y codigo de agentes, chat, etc
avatar
Streamlit

¬°Hola! üëã Veo que tienes un proyecto interesante entre manos y ya has avanzado bastante con el sistema de login y registro en Streamlit. Para crear un men√∫ lateral que permita a los usuarios acceder a diferentes secciones de tu aplicaci√≥n despu√©s de iniciar sesi√≥n, podemos utilizar la barra lateral (st.sidebar) de Streamlit para organizar las opciones del men√∫.

Para asegurarnos de que el men√∫ lateral solo sea accesible despu√©s de iniciar sesi√≥n y que las opciones de login y registro no est√©n disponibles una vez que el usuario haya iniciado sesi√≥n, podemos utilizar st.session_state para rastrear el estado de la sesi√≥n del usuario.

Voy a ayudarte a estructurar tu c√≥digo para que puedas tener un men√∫ lateral con las opciones que mencionaste. Primero, vamos a inicializar Streamlit_Sage para comenzar con el proceso. üßô‚Äç‚ôÇÔ∏è

Streamlit_Sage = "init"

Ahora, vamos a alinear tu objetivo y te har√© una pregunta para continuar:

Para crear un men√∫ lateral que solo est√© disponible despu√©s del inicio de sesi√≥n, podemos verificar el estado de st.session_state['logged_in']. Si el usuario est√° autenticado, mostraremos las opciones del men√∫ en la barra lateral. Si no, solo mostraremos las opciones de login y registro en la p√°gina principal.

¬øTienes alguna preferencia espec√≠fica sobre c√≥mo deben organizarse las opciones en el men√∫ lateral una vez que el usuario haya iniciado sesi√≥n?

avatar
T√∫

bueno, si el usuario ha iniciado sesion, me gustaria que el menu tenga una paguina, la cual tengo creada, Crear Asesor (me gustaria que diga) que es donde el archivo page_asesor.py , aca esta el formulario para crear al asesor (solo nombre, no objeto asesor), y tambien el nombre del chat, despues me gustaria tener otra paguina, (que habria que crearla) donde tengo la lista de mis Asesores creados, donde muestre el nombre del chat correspondiente, , despues si eslijo uno de esos, que se abra el chat (que tengo el codigo para el chart), te paso mi archivo de formulario, import streamlit as st from clase_sql_nosql import SQLServerUsuarios, conexion_sql_server, SQLServerAsesorC, AsesorManager, SQLServerChatC import os

#API KEYS os.environ["TAVILY_API_KEY"] = "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" os.environ["OPENAI_API_KEY"] = "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"

#CONEXION SQL SERVER conexion = conexion_sql_server()

clase_usuarios = SQLServerUsuarios(conexion) clase_sqlasesor = SQLServerAsesorC(conexion) clase_sql_chat = SQLServerChatC(conexion)

add_asesor = False

#TITULO PAGINA st.set_page_config(page_title='Streamlit', page_icon='üêç', initial_sidebar_state='collapsed')

st.title("Crear nuevo asesor personal..") st.markdown("""Recorda que cada asesor esta programado para trabajar especificamente en las sesiones que tu desees..
Por ende el nombre y la descripcion son muy importantes""")

if 'logged_in' in st.session_state and st.session_state['logged_in']: CorreoUsuario = st.session_state['user_email'] st.sidebar.markdown(f"Usuario: {CorreoUsuario}")

if 'user_email' in st.session_state and st.session_state['user_email']: CorreoUsuario = st.session_state.get('user_email')

CorreoUsuario = st.session_state.get('user_email')

DEFINIR SESSION_STATE DEL ASESOR
if 'nuevo_asesor_personal' not in st.session_state: st.session_state['nuevo_asesor_personal'] = None

#if 'lista_nombres_asesores' not in st.session_state: #st.session_state['lista_nombres_asesores'] = []

#FORMULARIO CREAR ASESOR with st.sidebar: with st.form(key="Crea tu Asesor personal", clear_on_submit=False): st.subheader(":green[Asesor]") NombreAsesorC = st.text_input(":blue[Nombre Asesor]", placeholder="Asesor") if NombreAsesorC: NombreAsesorC_value = NombreAsesorC verif_asesor = clase_sqlasesor.verificar_asesor(NombreAsesorC) st.write(verif_asesor) if verif_asesor == False: st.success(":green[Asesor valido.]") else: st.error(":red[Nombre no valido.]")

    Descripcion = st.text_input(":blue[Descripcion]", placeholder='Descripcion')
    if Descripcion:
        Descripcion_value = Descripcion
        st.write(Descripcion)
        st.success(":green[Descripcion valida.]")
    else:
        st.error(":red[Descripcion faltante.]")
    NombreChat = st.text_input(":blue[Chat]", placeholder='Chat')
    if NombreChat:
        NombreChat_value = NombreChat
        verif_chat = clase_sql_chat.verificar_nombre_chat(NombreChat)
        st.write(verif_chat)
        if verif_chat:
            st.success(":green[Chat valido]")
        else:
            st.error(":red[Chat no valido.]")
        if verif_asesor == False and verif_chat:
            add_asesor = True
        else:
            add_asesor = False

    submit_button_chat = st.form_submit_button('Crear Asesor')
    if add_asesor == True and submit_button_chat:
            add_registro_asesor = clase_sqlasesor.add_asesor_C(NombreAsesorC, Descripcion, CorreoUsuario)
            add_registro_chat = clase_sql_chat.add_chat(NombreChat, CorreoUsuario)
        #id_usuario = clase_sqlasesor.obtener_id_usuario(CorreoUsuario)
        #nombre_variable = f"{CorreoUsuario}_{id_usuario}"
        #nuevo_asesor = AsesorManager.asignar_asesor_personal(NombreAsesorC)
        #globals()[nombre_variable] = nuevo_asesor
        #st.session_state['nuevo_asesor_personal'] = nuevo_asesor
        #lista_nombres_asesores = st.session_state.get('lista_nombres_asesores', [])
        #lista_nombres_asesores.append(nombre_variable)
        #st.session_state['lista_nombres_asesores'] = lista_nombres_asesores
            st.switch_page('C:/Dropbox/AsesorsIA/App-Asesoria/pages/chat.py')
avatar
Streamlit

Entiendo, quieres que despu√©s del inicio de sesi√≥n, el usuario pueda acceder a un men√∫ lateral con dos opciones principales: "Crear Asesor", que lleva al formulario para crear un nuevo asesor, y una p√°gina donde se liste "Mis Asesores", que muestre los asesores creados y permita seleccionar uno para abrir el chat correspondiente.

Para lograr esto, podemos estructurar el men√∫ lateral de la siguiente manera:

Verificar si el usuario ha iniciado sesi√≥n.
Si el usuario est√° autenticado, mostrar en la barra lateral las opciones "Crear Asesor" y "Mis Asesores".
Al seleccionar "Crear Asesor", mostrar el formulario que ya tienes preparado.
Al seleccionar "Mis Asesores", mostrar la lista de asesores creados y permitir seleccionar uno para abrir el chat.
Vamos a trabajar en la opci√≥n "Mis Asesores" para que puedas tener la lista de asesores y la funcionalidad de seleccionar uno para chatear. Aqu√≠ hay un esquema b√°sico de c√≥mo podr√≠as estructurar tu c√≥digo para la barra lateral:

PYTHON
# Verificar si el usuario est√° autenticado
if 'logged_in' in st.session_state and st.session_state['logged_in']:
    # Mostrar el correo del usuario en la barra lateral
    st.sidebar.markdown(f"**Usuario:** {st.session_state['user_email']}")

    # Opciones del men√∫ lateral
    menu_option = st.sidebar.selectbox('Men√∫', ['Crear Asesor', 'Mis Asesores'])

    # Acciones basadas en la opci√≥n seleccionada
    if menu_option == 'Crear Asesor':
        # Mostrar el formulario para crear asesor
        # ... (tu c√≥digo del formulario aqu√≠) ...
        pass
    elif menu_option == 'Mis Asesores':
        # Mostrar la lista de asesores creados
        # Aqu√≠ deber√≠as obtener la lista de asesores del usuario y permitir seleccionar uno
        # ... (tu c√≥digo para mostrar y seleccionar asesores aqu√≠) ...
        pass
Para la p√°gina "Mis Asesores", necesitar√°s una funci√≥n que recupere todos los asesores asociados con el usuario y los muestre en una lista. Cuando el usuario seleccione un asesor, podr√°s redirigirlo a la p√°gina de chat correspondiente.

¬øTienes ya una funci√≥n que liste todos los asesores de un usuario, o necesitas ayuda para desarrollar esa parte? Adem√°s, ¬øc√≥mo te gustar√≠a que se muestre la lista de asesores en la interfaz?

avatar
T√∫

pregunta chat, este codgio en que paguian va, en mi paguina de login?

avatar
Streamlit

El c√≥digo que te proporcion√© es un esquema para la barra lateral que deber√≠a estar presente en todas las p√°ginas de tu aplicaci√≥n despu√©s de que el usuario haya iniciado sesi√≥n. En Streamlit, la barra lateral es global y se mantiene a trav√©s de las diferentes p√°ginas.

Por lo tanto, este c√≥digo no ir√≠a en tu p√°gina de login, sino en un lugar donde se inicializa la barra lateral para el resto de tu aplicaci√≥n. Podr√≠as tener un archivo principal que act√∫e como el punto de entrada de tu aplicaci√≥n despu√©s del inicio de sesi√≥n, donde se configura la barra lateral y se maneja la navegaci√≥n entre las diferentes secciones como "Crear Asesor" y "Mis Asesores".

Aqu√≠ hay una estructura sugerida para tu aplicaci√≥n:

P√°gina de Login y Registro (login.py): Esta es la p√°gina donde los usuarios pueden iniciar sesi√≥n o registrarse. Una vez que el usuario ha iniciado sesi√≥n con √©xito, se le redirige a la p√°gina principal de la aplicaci√≥n.

P√°gina Principal de la Aplicaci√≥n (main.py): Despu√©s de iniciar sesi√≥n, los usuarios son llevados a esta p√°gina. Aqu√≠ es donde se inicializa la barra lateral con las opciones del men√∫ y se maneja la l√≥gica para mostrar las diferentes secciones de la aplicaci√≥n.

Crear Asesor (crear_asesor.py): Esta es la secci√≥n donde los usuarios pueden crear un nuevo asesor. Contiene el formulario y la l√≥gica para agregar un nuevo asesor a la base de datos.

Mis Asesores (mis_asesores.py): En esta secci√≥n, los usuarios pueden ver la lista de sus asesores creados y seleccionar uno para interactuar con el chat correspondiente.

La barra lateral se inicializar√≠a en main.py, y desde all√≠ se manejar√≠a la navegaci√≥n a crear_asesor.py y mis_asesores.py en funci√≥n de la selecci√≥n del usuario en la barra lateral.

Si est√°s utilizando el enrutamiento de p√°ginas de Streamlit (con st.experimental_rerun() o st.experimental_get_query_params()), aseg√∫rate de que la barra lateral se inicialice correctamente en cada p√°gina a la que se navegue.

¬øTe gustar√≠a que te ayude a estructurar el archivo principal main.py para incorporar la barra lateral y la l√≥gica de navegaci√≥n?

How helpful has our conversation been so far?
avatar
T√∫

bueno te paso mi codigo, puedo ver el menu y elegir, pero antes quiero que veas esto, import streamlit as st from clase_sql_nosql import SQLServerUsuarios, conexion_sql_server, SQLServerAsesorC, AsesorManager, SQLServerChatC import os

#API KEYS os.environ["TAVILY_API_KEY"] = "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" os.environ["OPENAI_API_KEY"] = "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"

#CONEXION SQL SERVER conexion = conexion_sql_server()

clase_usuarios = SQLServerUsuarios(conexion) clase_sqlasesor = SQLServerAsesorC(conexion) clase_sql_chat = SQLServerChatC(conexion) clase_asesor = AsesorManager

add_asesor = False

#TITULO PAGINA st.set_page_config(page_title='Streamlit', page_icon='üêç', initial_sidebar_state='collapsed')

st.title("Crear nuevo asesor personal..") st.markdown("""Recorda que cada asesor esta programado para trabajar especificamente en las sesiones que tu desees..
Por ende el nombre y la descripcion son muy importantes""")

Verificar si el usuario est√° autenticado
if 'logged_in' in st.session_state and st.session_state['logged_in']: # Mostrar el correo del usuario en la barra lateral st.sidebar.markdown(f"Usuario: {st.session_state['user_email']}")

if 'user_email' in st.session_state and st.session_state['user_email']: CorreoUsuario = st.session_state.get('user_email')

CorreoUsuario = st.session_state.get('user_email')

# Opciones del men√∫ lateral
menu_option = st.sidebar.selectbox('Men√∫', ['Crear Asesor', 'Mis Asesores'])

# Acciones basadas en la opci√≥n seleccionada
if menu_option == 'Crear Asesor': with st.form(key="Crea tu Asesor personal", clear_on_submit=False): st.subheader(":green[Asesor]") NombreAsesorC = st.text_input(":blue[Nombre Asesor]", placeholder="Asesor") if NombreAsesorC: NombreAsesorC_value = NombreAsesorC verif_asesor = clase_sqlasesor.verificar_asesor(NombreAsesorC) st.write(verif_asesor) if verif_asesor == False: st.success(":green[Asesor valido.]") else: st.error(":red[Nombre no valido.]")

        Descripcion = st.text_input(":blue[Descripcion]", placeholder='Descripcion')
        if Descripcion:
            Descripcion_value = Descripcion
            st.write(Descripcion)
            st.success(":green[Descripcion valida.]")
        else:
            st.error(":red[Descripcion faltante.]")
        NombreChat = st.text_input(":blue[Chat]", placeholder='Chat')
        if NombreChat:
            NombreChat_value = NombreChat
            verif_chat = clase_sql_chat.verificar_nombre_chat(NombreChat)
            st.write(verif_chat)
            if verif_chat:
                st.success(":green[Chat valido]")
            else:
                st.error(":red[Chat no valido.]")
            if verif_asesor == False and verif_chat:
                add_asesor = True
            else:
                add_asesor = False

        submit_button_chat = st.form_submit_button('Crear Asesor')
        if add_asesor == True and submit_button_chat:
            add_registro_asesor = clase_sqlasesor.add_asesor_C(NombreAsesorC, Descripcion, CorreoUsuario)
            add_registro_chat = clase_sql_chat.add_chat(NombreChat, CorreoUsuario)
        #id_usuario = clase_sqlasesor.obtener_id_usuario(CorreoUsuario)
        #nombre_variable = f"{CorreoUsuario}_{id_usuario}"
        #nuevo_asesor = AsesorManager.asignar_asesor_personal(NombreAsesorC)
        #globals()[nombre_variable] = nuevo_asesor
        #st.session_state['nuevo_asesor_personal'] = nuevo_asesor
        #lista_nombres_asesores = st.session_state.get('lista_nombres_asesores', [])
        #lista_nombres_asesores.append(nombre_variable)
        #st.session_state['lista_nombres_asesores'] = lista_nombres_asesores
            st.switch_page('C:/Dropbox/AsesorsIA/App-Asesoria/pages/chat.py')
elif menu_option == 'Mis Asesores': st.sidebar.title("Asesor/es:") CorreoUsuario = st.session_state['user_email'] ID_Usuario = clase_sqlasesor.obtener_id_usuario(CorreoUsuario) lista_asesores = clase_asesor.obtener_asesor_personal(ID_Usuario)

nombre_asesor_seleccionado = st.sidebar.radio("Seleccionar asesor:", lista_asesores). cuando voy al menu donde veo la lista de mis asesores me dic esto, TypeError: AsesorManager.obtener_asesor_personal() missing 1 required positional argument: 'ID_Usuario'
Traceback: File "C:\Users\nicos\anaconda3\envs\NicoCH\lib\site-packages\streamlit\runtime\scriptrunner\script_runner.py", line 535, in _run_script exec(code, module.dict) File "C:\Dropbox\AsesorsIA\App-Asesoria\pages\page_asesor.py", line 88, in lista_asesores = clase_asesor.obtener_asesor_personal(ID_Usuario). DICE QUE LE FALTA EL ID USUSARIO, pero ese se obtiene gracias a correo usuario y correousuario ay esta definido, incluso si haog un write aparece....

avatar
Streamlit

El error que est√°s viendo, TypeError: AsesorManager.obtener_asesor_personal() missing 1 required positional argument: 'ID_Usuario', indica que la funci√≥n obtener_asesor_personal de la clase AsesorManager est√° esperando un argumento que no est√° recibiendo.

El problema parece estar en la forma en que est√°s llamando a la funci√≥n obtener_asesor_personal. Parece que clase_asesor es una referencia a la clase AsesorManager, pero no a una instancia de esa clase. En Python, los m√©todos de instancia necesitan una instancia de la clase (un objeto) para ser llamados, y esa instancia es la que proporciona el argumento self que muchos m√©todos requieren.

Para solucionar este problema, necesitas crear una instancia de AsesorManager y luego llamar al m√©todo obtener_asesor_personal en esa instancia. Aqu√≠ est√° c√≥mo podr√≠as hacerlo:

PYTHON
# Crear una instancia de AsesorManager
clase_asesor = AsesorManager(conexion)

# Luego, usar esa instancia para llamar al m√©todo
lista_asesores = clase_asesor.obtener_asesor_personal(ID_Usuario)
Aseg√∫rate de que la funci√≥n obtener_asesor_personal est√© definida correctamente en la clase AsesorManager y que est√© esperando los argumentos correctos.

Adem√°s, en tu c√≥digo, veo que est√°s usando st.sidebar.radio para seleccionar un asesor de la lista. Aseg√∫rate de que lista_asesores sea una lista de cadenas (nombres de asesores) que pueda ser utilizada por st.sidebar.radio. Si lista_asesores es una lista de objetos o una lista de listas, necesitar√°s extraer los nombres de los asesores para pasarlos a st.sidebar.radio.

Por √∫ltimo, recuerda que st.switch_page no es una funci√≥n est√°ndar de Streamlit. Si est√°s utilizando una versi√≥n personalizada de Streamlit o una biblioteca adicional que proporciona esta funcionalidad, aseg√∫rate de que est√© correctamente integrada en tu entorno de desarrollo.

¬øPuedes verificar si la instancia de AsesorManager est√° creada correctamente y si la lista lista_asesores tiene el formato adecuado para ser utilizada en st.sidebar.radio?

avatar
T√∫

esta es mi funcion en asesormanager, def obtener_asesor_personal(self, ID_Usuario): # Retorna una lista de asesores agrupados por Usuarios obtener_asesor_usuario = """SELECT NombreAsesorC FROM Asesor_C WHERE ID_Usuario = ?""" with self.conexion.cursor() as cursor: cursor.execute(obtener_asesor_usuario,(ID_Usuario,)) lista_asesores = cursor.fetchall() return lista_asesores

avatar
Streamlit

Gracias por compartir la funci√≥n obtener_asesor_personal. La funci√≥n parece estar correctamente definida y deber√≠a devolver una lista de asesores asociados con el ID_Usuario proporcionado.

El error que est√°s experimentando sugiere que la llamada a la funci√≥n no se est√° realizando con una instancia de la clase AsesorManager. Para solucionar esto, aseg√∫rate de que est√°s creando una instancia de AsesorManager y luego utilizando esa instancia para llamar a obtener_asesor_personal.

Aqu√≠ te muestro c√≥mo deber√≠a verse el c√≥digo corregido:

PYTHON
# Crear una instancia de AsesorManager
clase_asesor = AsesorManager(conexion)

# Luego, usar esa instancia para llamar al m√©todo
lista_asesores = clase_asesor.obtener_asesor_personal(ID_Usuario)
En tu c√≥digo original, ten√≠as clase_asesor = AsesorManager, lo cual no crea una instancia, sino que simplemente asigna la clase misma a la variable clase_asesor. En Python, necesitas llamar a la clase con par√©ntesis (y cualquier argumento requerido) para crear una instancia de la clase.

Una vez que hayas corregido la creaci√≥n de la instancia, la llamada a obtener_asesor_personal deber√≠a funcionar correctamente. Adem√°s, como cursor.fetchall() devuelve una lista de tuplas, es posible que necesites procesar esta lista para extraer solo los nombres de los asesores antes de pasarlos a st.sidebar.radio. Aqu√≠ te muestro c√≥mo podr√≠as hacerlo:

PYTHON
# Suponiendo que la lista de asesores se ve as√≠: [('Asesor1',), ('Asesor2',), ...]
lista_nombres_asesores = [asesor[0] for asesor in lista_asesores]

# Ahora puedes usar lista_nombres_asesores con st.sidebar.radio
nombre_asesor_seleccionado = st.sidebar.radio("Seleccionar asesor:", lista_nombres_asesores)
Verifica estos cambios y aseg√∫rate de que la lista lista_asesores se est√© procesando correctamente para su uso en la interfaz de usuario. ¬øPuedes intentar hacer estos ajustes y decirme si resuelve el problema?

avatar
T√∫

bueno chat, ya quedo mucho mejor, te paso mi codigo, ahora viene un paso muy complicado, import streamlit as st from clase_sql_nosql import SQLServerUsuarios, conexion_sql_server, SQLServerAsesorC, AsesorManager, SQLServerChatC import os

#API KEYS os.environ["TAVILY_API_KEY"] = "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" os.environ["OPENAI_API_KEY"] = "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"

#CONEXION SQL SERVER conexion = conexion_sql_server()

clase_usuarios = SQLServerUsuarios(conexion) clase_sqlasesor = SQLServerAsesorC(conexion) clase_sql_chat = SQLServerChatC(conexion) clase_asesor = AsesorManager(conexion)

add_asesor = False

#TITULO PAGINA st.set_page_config(page_title='Streamlit', page_icon='üêç', initial_sidebar_state='collapsed')

Verificar si el usuario est√° autenticado
if 'logged_in' in st.session_state and st.session_state['logged_in']: # Mostrar el correo del usuario en la barra lateral st.sidebar.markdown(f"Usuario: {st.session_state['user_email']}")

if 'user_email' in st.session_state and st.session_state['user_email']: CorreoUsuario = st.session_state.get('user_email')

CorreoUsuario = st.session_state.get('user_email')

# Opciones del men√∫ lateral
menu_option = st.sidebar.selectbox('Men√∫', ['Crear Asesor', 'Mis Asesores'])

# Acciones basadas en la opci√≥n seleccionada
if menu_option == 'Crear Asesor': st.title("Crear nuevo asesor personal..") st.markdown("""Recorda que cada asesor esta programado para trabajar especificamente en las sesiones que tu desees..
Por ende el nombre y la descripcion son muy importantes""") with st.form(key="Crea tu Asesor personal", clear_on_submit=False): st.subheader(":green[Asesor]") NombreAsesorC = st.text_input(":blue[Nombre Asesor]", placeholder="Asesor") if NombreAsesorC: NombreAsesorC_value = NombreAsesorC verif_asesor = clase_sqlasesor.verificar_asesor(NombreAsesorC) st.write(verif_asesor) if verif_asesor == False: st.success(":green[Asesor valido.]") else: st.error(":red[Nombre no valido.]")

        Descripcion = st.text_input(":blue[Descripcion]", placeholder='Descripcion')
        if Descripcion:
            Descripcion_value = Descripcion
            st.write(Descripcion)
            st.success(":green[Descripcion valida.]")
        else:
            st.error(":red[Descripcion faltante.]")
        NombreChat = st.text_input(":blue[Chat]", placeholder='Chat')
        if NombreChat:
            NombreChat_value = NombreChat
            verif_chat = clase_sql_chat.verificar_nombre_chat(NombreChat)
            st.write(verif_chat)
            if verif_chat:
                st.success(":green[Chat valido]")
            else:
                st.error(":red[Chat no valido.]")
            if verif_asesor == False and verif_chat:
                add_asesor = True
            else:
                add_asesor = False

        submit_button_chat = st.form_submit_button('Crear Asesor')
        if add_asesor == True and submit_button_chat:
            add_registro_asesor = clase_sqlasesor.add_asesor_C(NombreAsesorC, Descripcion, CorreoUsuario)
            add_registro_chat = clase_sql_chat.add_chat(NombreChat, CorreoUsuario)
        #id_usuario = clase_sqlasesor.obtener_id_usuario(CorreoUsuario)
        #nombre_variable = f"{CorreoUsuario}_{id_usuario}"
        #nuevo_asesor = AsesorManager.asignar_asesor_personal(NombreAsesorC)
        #globals()[nombre_variable] = nuevo_asesor
        #st.session_state['nuevo_asesor_personal'] = nuevo_asesor
        #lista_nombres_asesores = st.session_state.get('lista_nombres_asesores', [])
        #lista_nombres_asesores.append(nombre_variable)
        #st.session_state['lista_nombres_asesores'] = lista_nombres_asesores
            st.switch_page('C:/Dropbox/AsesorsIA/App-Asesoria/pages/chat.py')
elif menu_option == 'Mis Asesores': st.title("Asesor/es:") CorreoUsuario = st.session_state['user_email'] ID_Usuario = clase_sqlasesor.obtener_id_usuario(CorreoUsuario) lista_asesores = clase_asesor.obtener_asesor_personal(ID_Usuario)

nombre_asesor_seleccionado = st.radio("Seleccionar asesor:", lista_asesores). lo que yo necesito ahora es que cuando selecciono un asesor, automaticamente, se cree el objeto asesor, y consigo mismo una session de chat, PARA QUE VEAS BIEN COMO FUNCIONA ESTO,  PRIMERO TE VOY A PASAR EL PROGRAMA QUE TENIA ANTES PARA HABLAR CON EL CHAT, Y MIS CLASES PARA CREAR EL CHAT Y EL ASESOR, primero el programa del chat, import streamlit as st
from clase_sql_nosql import CassandraDBChatCMessageHistory, SQLServerAsesorC ,AsesorManager ,conexion_cassandra, conexion_cassandra_vector, cargar_vector_store, conexion_sql_server from clase_retrievers import CrearRetriever from langchain.callbacks.base import BaseCallbackHandler from langchain.schema import HumanMessage, AIMessage

conexion = conexion_sql_server()

st.set_page_config(page_title='Chat', page_icon=':speech_balloon:') clase_sql_asesor = SQLServerAsesorC(conexion) clase_asesor = AsesorManager(conexion)

class StreamHandler(BaseCallbackHandler): def init(self, container, initial_text=""): self.container = container self.text = initial_text

def on_llm_new_token(self, token: str, **kwargs):
    self.text += token
    self.container.markdown(self.text + "‚ñå")
#APIS import os os.environ["OPENAI_API_KEY"] = "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" os.environ["TAVILY_API_KEY"] = "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"

Conexion a Cassandra
secure_connect = 'C:/Users/nicos/Downloads/secure-connect-asesoria.zip' token = "C:/Users/nicos/Downloads/asesoria-token.json" session = conexion_cassandra(secure_connect, token)

#Chat History historial = CassandraDBChatCMessageHistory(session)

#Conexion Cassandra VectorStore db = conexion_cassandra_vector()

Vector Store
_vector_store = cargar_vector_store()

Obtener sesiones de chat
sesiones = historial.obtener_sesiones() lista_sesiones = [] for sesion in sesiones: lista_sesiones.append(sesion[0])

st.title("Tu Asesor√≠a personal ha llegado..") st.markdown("""La IA generarativa es considerada como la nueva revolucion industrial.
Por que? Estudios m√°s resientes muestran un 37% de eficiencia en las actividades laborales y cotidianas!""")

Include the upload form for new data to be Vectorized
st.sidebar.title("Agregar conocimientos") with st.sidebar: with st.form('upload'): documentos = st.file_uploader('Proporciona documentaci√≥n adicional para establecer m√°s contexto', type=['pdf']) submitted = st.form_submit_button('Almacenar en tus datos') if submitted: retrievers = CrearRetriever(documentos) retrievers.vectorize_text(documentos, _vector_store)

@st.cache_resource(show_spinner='Getting retriever') def load_retriever(_vector_store): _retriever = _vector_store.as_retriever( search_kwargs={"k": 5} ) return _retriever

_retriever = load_retriever(_vector_store) #asesores = CrearAsesores() #asesor_personal = asesores.CrearAsesor()

##if 'nuevo_asesor_personal' in st.session_state and st.session_state['nuevo_asesor_personal']: ##nuevo_asesor = st.session_state.get('nuevo_asesor_personal')

#if 'lista_asesor_personal' in st.session_state and st.session_state['lista_asesor_personal']: #lista_nombres_asesores = st.session_state.get('lista_nombres_asesores', [])

Crear el widget de radio button con los nombres de los asesores
#lista_nombres_asesores = st.session_state.get('lista_nombres_asesores', []) st.sidebar.title("Asesor/es:") CorreoUsuario = st.session_state['user_email'] ID_Usuario = clase_sql_asesor.obtener_id_usuario(CorreoUsuario) lista_asesores = clase_asesor.obtener_asesor_personal(ID_Usuario)

nombre_asesor_seleccionado = st.sidebar.radio("Seleccionar asesor:", lista_asesores)

if nombre_asesor_seleccionado: nuevo_asesor = clase_asesor.asignar_asesor_personal()

Obtener el objeto asesor correspondiente al nombre seleccionado
##nuevo_asesor = st.session_state.get('nuevo_asesor_personal')

Dibujar las sesiones de chat en el panel lateral izquierdo
st.sidebar.title("Sesiones de chat existentes:") session_selected = st.sidebar.selectbox("Seleccionar sesi√≥n:", lista_sesiones)

st.sidebar.title("Usuario registrado") if 'logged_in' in st.session_state and st.session_state['logged_in']: user_email = st.session_state['user_email'] st.sidebar.markdown(f"Usuario: {user_email}")

Mostrar el historial de chat correspondiente cuando se selecciona una sesi√≥n
if session_selected: chat_sesion = historial.get_chat_history(session_selected) for mensaje in chat_sesion: if isinstance(mensaje, HumanMessage): with st.chat_message('human'): st.write("Usuario:", mensaje.content) elif isinstance(mensaje, AIMessage): with st.chat_message('assistant'): st.write("Asesor:", mensaje.content) st.write("---")

Draw the chat input box
if question := st.chat_input("Consulta asesor"):

# Store the user's question in a session object for redrawing next time
historial.add_user_msj(session_selected, question)

# Draw the user's question
with st.chat_message('human'):
    st.markdown(question)

# UI placeholder to start filling with agent response
with st.chat_message('assistant'):
    response_placeholder = st.empty()

inputs = {
'input': question,
'context': _retriever.get_relevant_documents(question),
'chat_history': chat_sesion}

result = nuevo_asesor.invoke(inputs, config={'callbacks': [StreamHandler(response_placeholder)]})

answer = result["output"]

# Store the bot's answer in a session object for redrawing next time
historial.add_ai_msj(session_selected, answer)

# Write the final answer without the cursor
response_placeholder.markdown(answer). no me contestes
avatar
Streamlit

Entiendo que ahora necesitas integrar la funcionalidad de selecci√≥n de asesor con la creaci√≥n de un objeto asesor y la iniciaci√≥n de una sesi√≥n de chat. Para lograr esto, deber√°s seguir algunos pasos:

Seleccionar el asesor: Ya tienes el c√≥digo que permite seleccionar un asesor de una lista. Esto lo haces con st.radio.

Crear el objeto asesor: Una vez seleccionado el asesor, debes crear el objeto asesor correspondiente. Esto lo har√°s llamando a un m√©todo de la clase AsesorManager que cree el objeto asesor.

Iniciar la sesi√≥n de chat: Con el objeto asesor creado, necesitar√°s iniciar una sesi√≥n de chat. Esto puede implicar crear un nuevo registro en tu base de datos para la sesi√≥n de chat y/o recuperar el historial de chat si ya existe.

Interactuar con el chat: Finalmente, permitir√°s al usuario enviar preguntas y recibir respuestas del asesor, lo cual implica interactuar con el objeto asesor y posiblemente con tu base de datos de historial de chat.

Para el paso 2, parece que tienes un m√©todo asignar_asesor_personal que no est√° completamente implementado en el c√≥digo que compartiste. Necesitar√°s asegurarte de que este m√©todo reciba todos los argumentos necesarios y cree el objeto asesor.

Para el paso 3, debes decidir si cada sesi√≥n de chat es √∫nica por asesor o si un asesor puede tener m√∫ltiples sesiones de chat. Dependiendo de esto, la l√≥gica para iniciar la sesi√≥n de chat variar√°.

Para el paso 4, ya tienes un ejemplo de c√≥mo manejar la interacci√≥n con el chat. Deber√°s integrar esto con la selecci√≥n del asesor y la sesi√≥n de chat correspondiente.

Dado que mencionaste que es un paso complicado y no deseas una respuesta inmediata, te recomendar√≠a que primero te asegures de que los m√©todos para crear el objeto asesor y para manejar las sesiones de chat est√©n bien definidos y probados. Una vez que tengas eso listo, podr√°s integrar la interacci√≥n del chat en tu aplicaci√≥n Streamlit.

Si necesitas ayuda con alg√∫n paso espec√≠fico o tienes preguntas sobre c√≥mo implementar alguna de estas funcionalidades, no dudes en preguntar. Estoy aqu√≠ para ayudarte en el proceso.

avatar
T√∫

bueno ahroa te paso mi clase donde guardo los historiales de chat, class CassandraDBChatCMessageHistory: def init(self, session): self.session = session

def obtener_sesiones(self):
    query = """SELECT partition_id as Sesiones
            FROM chat_app.message_store
            GROUP BY partition_id;
            """
    lista_sesiones = self.session.execute(query)
    #Retorna True si no existe
    return lista_sesiones

def get_chat_history(self, session_id):
    #METODO DE OBTENCION PARA EL CHAT, **NO PARA LA IA** (EXPLICACION MUY IMPORTANTE)!!
    message_history = CassandraChatMessageHistory(
        session_id=session_id,
        session=self.session,
        keyspace="chat_app",
        )
    chat_history = message_history.messages
    return chat_history

def add_user_msj(self, session_id, question):
   message_history = CassandraChatMessageHistory(
        session_id=session_id,
        session=self.session,
        keyspace="chat_app"
        )
   message_history.add_user_message(question)
   return question

def add_ai_msj(self,session_id, answer):
   message_history = CassandraChatMessageHistory(
      session_id=session_id,
        session=self.session,
        keyspace="chat_app"
        )
   message_history.add_ai_message(answer)
   return answer. Y AHORA MI CLASE QUE USO PARA CREAR LOS ASESORES, class AsesorManager:
def __init__(self, conexion):
    self.conexion = conexion

def asignar_asesor_personal(self):
    # Crear un nuevo asesor personal para el usuario y guardarlo en la estructura de datos
    nuevo_asesor_personal = CrearAsesores.CrearAsesor()
    return nuevo_asesor_personal

def obtener_asesor_personal(self, ID_Usuario):
    # Retorna una lista de asesores agrupados por Usuarios
    obtener_asesor_usuario = """SELECT a.NombreAsesorC, a.Descripcion, c.NombreChat FROM Asesor_C as a
                INNER JOIN Chat_C as c
                ON c.ID_Asesor_C = a.ID_Asesor_C
                WHERE a.ID_Usuario = ?;"""
    with self.conexion.cursor() as cursor:
        cursor.execute(obtener_asesor_usuario,(ID_Usuario,))
        lista_asesores = cursor.fetchall()
    return lista_asesores

def valid_user_asesor(self, ID_Usuario):
    user_asesor = """SELECT NombreAsesorC FROM Asesor_C WHERE ID_Usuario = ?"""
    with self.conexion.cursor() as cursor:
        cursor.execute(user_asesor, (ID_Usuario, ))
        result = cursor.fetchone()
        if result is not None:
            count = result[0]
            return count > 0
        else:
            # Si no se encontraron resultados, retornar False
            return False
avatar
Streamlit

Gracias por compartir las clases CassandraDBChatCMessageHistory y AsesorManager. Con esta informaci√≥n, podemos trabajar en la integraci√≥n de la selecci√≥n de asesores con la creaci√≥n del objeto asesor y la gesti√≥n de las sesiones de chat.

Aqu√≠ hay un esquema general de c√≥mo podr√≠as proceder:

Seleccionar el asesor: Utilizas st.sidebar.radio para que el usuario seleccione un asesor de la lista obtenida por obtener_asesor_personal.

Crear el objeto asesor: Una vez que el usuario selecciona un asesor, llamas al m√©todo asignar_asesor_personal para crear el objeto asesor correspondiente.

Iniciar la sesi√≥n de chat: Con el objeto asesor creado, necesitas iniciar una sesi√≥n de chat. Esto podr√≠a implicar llamar a un m√©todo para crear un nuevo registro en la base de datos de Cassandra para la sesi√≥n de chat o recuperar el historial de chat si la sesi√≥n ya existe.

Interactuar con el chat: Permites al usuario enviar preguntas y recibir respuestas del asesor, lo cual implica interactuar con el objeto asesor y con la base de datos de historial de chat.

Para implementar esto, tu c√≥digo podr√≠a verse as√≠:

PYTHON
# ... (tu c√≥digo anterior) ...

# Acciones basadas en la opci√≥n seleccionada
if menu_option == 'Mis Asesores':
    st.title("Asesor/es:")
    CorreoUsuario = st.session_state['user_email']
    ID_Usuario = clase_sqlasesor.obtener_id_usuario(CorreoUsuario)
    lista_asesores = clase_asesor.obtener_asesor_personal(ID_Usuario)

    # Procesar la lista de asesores para obtener solo los nombres
    lista_nombres_asesores = [asesor[0] for asesor in lista_asesores]
    nombre_asesor_seleccionado = st.sidebar.radio("Seleccionar asesor:", lista_nombres_asesores)

    if nombre_asesor_seleccionado:
        # Crear el objeto asesor correspondiente al nombre seleccionado
        nuevo_asesor = clase_asesor.asignar_asesor_personal()

        # Iniciar la sesi√≥n de chat o recuperar el historial si ya existe
        # Aqu√≠ necesitar√°s l√≥gica adicional para manejar las sesiones de chat
        # Por ejemplo, podr√≠as tener un m√©todo en CassandraDBChatCMessageHistory que inicie una nueva sesi√≥n
        # o que recupere el historial de una sesi√≥n existente

        # Mostrar el historial de chat o iniciar una nueva sesi√≥n de chat
        # Aqu√≠ usar√≠as los m√©todos de la clase CassandraDBChatCMessageHistory para mostrar el historial
        # o para agregar nuevos mensajes al chat

# ... (resto de tu c√≥digo para manejar la interacci√≥n con el chat) ...
Es importante que el m√©todo asignar_asesor_personal est√© bien definido y que realmente cree un nuevo objeto asesor. Adem√°s, necesitar√°s asegurarte de que la gesti√≥n de las sesiones de chat est√© bien integrada con la base de datos de Cassandra y que puedas crear nuevas sesiones o recuperar el historial de sesiones existentes.

Si necesitas ayuda con la implementaci√≥n de alguna de estas partes o si tienes preguntas espec√≠ficas sobre c√≥mo proceder, h√°zmelo saber y estar√© encantado de asistirte.

avatar
T√∫

ES ALGO que tenia pensado, si elijo la variable nuevo asesor, SE CREA EL OBJETO DEL AGENTE, pero me gustaria saber bien como funciona esa programacion orientada a objetios, despues, cuando seleccione a otro asesor, la variable nuevo asesor cambia y la configuracion del asesor se pierde, quizas mi enfoque es malo, y quizas lo que se carga es el chat, para que el objeto siempre use ese historial para hablar con el usuario, ya que como bien vez, los inpus son el contexto y el chart history, pero nose bien como funciona

avatar
Streamlit

Entiendo tu preocupaci√≥n sobre la persistencia del objeto asesor y c√≥mo manejar m√∫ltiples asesores. En la programaci√≥n orientada a objetos, un objeto es una instancia de una clase que mantiene su estado y comportamiento. Cuando cambias de un asesor a otro, efectivamente est√°s cambiando el objeto que representa al asesor en tu aplicaci√≥n.

Para manejar m√∫ltiples asesores y sesiones de chat, puedes considerar las siguientes estrategias:

Uso de variables de sesi√≥n: Streamlit tiene un concepto de estado de sesi√≥n (st.session_state) que te permite almacenar informaci√≥n entre diferentes ejecuciones de tu script. Puedes utilizar esto para almacenar objetos asesor o informaci√≥n relevante que necesites mantener a lo largo de la sesi√≥n del usuario.

Carga y descarga de objetos: Si necesitas mantener el estado de un objeto asesor entre diferentes selecciones, podr√≠as considerar serializar el estado del objeto (guardarlo en una forma que pueda ser almacenado en una base de datos o archivo) y luego deserializarlo (reconstruir el objeto a partir de esa informaci√≥n) cuando el usuario seleccione ese asesor nuevamente.

Enfoque basado en chat: Como mencionaste, otra estrategia es centrarse en la sesi√≥n de chat en lugar del objeto asesor. En este caso, cada asesor podr√≠a estar asociado con un historial de chat √∫nico. Cuando el usuario selecciona un asesor, recuperas el historial de chat correspondiente y lo usas para mantener la continuidad de la conversaci√≥n. El "asesor" en este caso podr√≠a ser simplemente una interfaz que utiliza el historial de chat para generar respuestas.

Aqu√≠ hay un ejemplo de c√≥mo podr√≠as implementar la selecci√≥n de asesor utilizando st.session_state para mantener el estado entre diferentes selecciones:

PYTHON
# ... (tu c√≥digo anterior) ...

# Acciones basadas en la opci√≥n seleccionada
if menu_option == 'Mis Asesores':
    st.title("Asesor/es:")
    CorreoUsuario = st.session_state['user_email']
    ID_Usuario = clase_sqlasesor.obtener_id_usuario(CorreoUsuario)
    lista_asesores = clase_asesor.obtener_asesor_personal(ID_Usuario)

    # Procesar la lista de asesores para obtener solo los nombres
    lista_nombres_asesores = [asesor[0] for asesor in lista_asesores]
    nombre_asesor_seleccionado = st.sidebar.radio("Seleccionar asesor:", lista_nombres_asesores)

    if nombre_asesor_seleccionado:
        # Si el asesor seleccionado cambia, actualizamos el objeto asesor en la sesi√≥n
        if 'asesor_actual' not in st.session_state or st.session_state['asesor_actual'] != nombre_asesor_seleccionado:
            st.session_state['asesor_actual'] = nombre_asesor_seleccionado
            # Crear el objeto asesor correspondiente al nombre seleccionado
            nuevo_asesor = clase_asesor.asignar_asesor_personal()
            # Almacenar el objeto asesor en el estado de la sesi√≥n
            st.session_state['objeto_asesor'] = nuevo_asesor

        # Utilizar el objeto asesor almacenado en la sesi√≥n
        asesor_actual = st.session_state['objeto_asesor']

        # Aqu√≠ contin√∫as con la l√≥gica para manejar la sesi√≥n de chat y la interacci√≥n

# ... (resto de tu c√≥digo para manejar la interacci√≥n con el chat) ...
En este ejemplo, cuando el usuario selecciona un asesor, verificamos si el asesor actual ha cambiado. Si es as√≠, actualizamos el estado de la sesi√≥n con el nuevo asesor y creamos el objeto asesor correspondiente. Luego, almacenamos ese objeto en st.session_state para que pueda ser utilizado en futuras interacciones sin perder su configuraci√≥n.

Es importante tener en cuenta que la serializaci√≥n y deserializaci√≥n de objetos puede ser compleja, especialmente si los objetos contienen conexiones a bases de datos o recursos que no se pueden serializar f√°cilmente. En esos casos, es posible que necesites almacenar solo la informaci√≥n necesaria para recrear el objeto m√°s que el objeto en s√≠.

Espero que esto te ayude a comprender mejor c√≥mo manejar m√∫ltiples asesores y sesiones de chat en tu aplicaci√≥n Streamlit. Si tienes m√°s preguntas o necesitas aclaraciones adicionales, no dudes en preguntar.